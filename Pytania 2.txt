
What is currying?

Currying is when you break down a function that takes multiple arguments into a series of functions 
that each take only one argument. Here's an example in JavaScript  

// function add (a, b) {
//   return a + b;
// }

// add(3, 4); // returns 7

This is a function that takes two arguments, a and b, and returns their sum. 
We will now curry this function:

// function add (a) {
//     return function (b) {
//       return a + b;
//     }
//   }


  This is a function that takes one argument, a, and returns a function that takes another argument, b,
   and that function returns their sum.

//    add(3)(4);

//     var add3 = add(3);

//     add3(4);

    The first statement returns 7, like the add(3, 4) statement. The second statement defines a new function
     called add3 that will add 3 to its argument. (This is what some may call a closure.) The third statement 
     uses the add3 operation to add 3 to 4, again producing 7 as a result.

 ===============================================


     Different ways of writing functions in JavaScript

     A Function is a block of code that is designed to perform a task and executed when it is been called or invoked.

    There are 3 ways of writing a function in JavaScript:

    Function Declaration
    Function Expression
    Arrow Function

1. function Declaration

function add(a,b) {
  console.log(a+b)
}

add(2,3)

2. Function expression:

Function Expression is another way to define a function in JavaScript.
 Here we define a function using a variable and store the returned value in that variable.

 const add = function(a, b) {
  console.log(a+b)
 }

 add(2, 3)


 3. Arrow Functions: Arrow functions are been introduced in the ES6 version of JavaScript.
  It is used to shorten the code. Here we do not use the “function” keyword and use the arrow symbol.


  let add = (a, b) => a + b;

  console.log(add(2, 3));


  ===================================

  React vs Angular differences

  React is written in JavaSctript when Angular is written in typescript
  

  =================================

  Statically vs. Dynamically typed language

Statically-----------

We call a language “statically-typed” if it follows type checking during compilation.
 So, every detail about the variables and all the data types must be known before we do
  the compiling process.

In this type of language, once a variable is assigned a type, it can’t be assigned to
 some other variable of a different type. If we try to do so, the compiler will raise some 
 errors, and we need to fix them. Hence, for a declared variable, the data type is fixed.

Some examples of statically-typed languages are Java, C, C++, C#, Swift, Scala, Kotlin,
 Fortran, Pascal, Rust, Go, COBOL, etc.

Dynamically---------


We call a language “dynamically typed” if type checking takes place while the program runs (run-time).
 In this type of language, there is no need to specify the data type of each variable while writing code.
It means that you can write pretty quickly since you do not have to specify types every time.
 Some languages do allow you to provide type information but do not require it.

Most modern programming languages are dynamically typed. Some examples of dynamically-typed languages
 are Python, Javascript, Ruby, Perl, PHP, R, Dart, Lua, Objective-C, etc.



========================

Var, let, const 

var variables can be re-declared and updated!!!!!!!

Scope essentially means where these variables are available for use.
 var declarations are globally scoped or function/locally scoped.

Hoisting is a JavaScript mechanism where variables and function declarations
 are moved to the top of their scope before code execution. This means that if we do this:

  console.log (greeter);
    var greeter = "say hello"

-----
LET 

let is block scoped
A block is a chunk of code bounded by {}. A block lives in curly braces.
 Anything within curly braces is a block.

So a variable declared in a block!!!!!!!! with let  is only available for use within
 that block. Let me explain this with an example:

 let greeting = "say Hi";
   let times = 4;

   if (times > 3) {
        let hello = "say Hello instead";
        console.log(hello);// "say Hello instead"
    }
   console.log(hello) // hello is not defined

   We see that using hello outside its block (the curly braces where it was defined) returns an error. 
   This is because let variables are block scoped .

let can be updated but not re-declared.
Just like var,  a variable declared with let can be updated within its scope. Unlike var, a let variable
 cannot be re-declared within its scope. So while this will work:

    let greeting = "say Hi";
    greeting = "say Hello instead";


    this will return an error:

     let greeting = "say Hi";
    let greeting = "say Hello instead"; // error: Identifier 'greeting' has already been declared

    Hoisting of let!!!!!!!!!!!
Just like  var, let declarations are hoisted to the top. Unlike var which is initialized as undefined,
 the let keyword is not initialized. So if you try to use a let variable before declaration, you'll get a Reference Error.


 --------------------
 CONST 

Variables declared with the const maintain constant values. const declarations 
share some similarities with let declarations.

const declarations are block scoped
Like let declarations, const declarations can only be accessed within the block they were declared.

const cannot be updated or re-declared
This means that the value of a variable declared with const remains the same within its scope.
 It cannot be updated or re-declared. So if we declare a variable with const, we can neither do this:

   const greeting = "say Hi";
    greeting = "say Hello instead";// error: Assignment to constant variable. 

    Every const declaration, therefore, must be initialized at the time of declaration.!!!!!!!!!!!


    This behavior is somehow different when it comes to objects declared with const. 
    While a const object cannot be updated, the properties of this objects can be updated. 
    Therefore, if we declare a const object as this:


    const greeting = {
        message: "say Hi",
        times: 4
    }

    Hoisting of const
Just like let, const declarations are hoisted to the top but are not initialized.


=============================

The strict equality operator (===) behaves identically to the abstract equality operator (==) except 
no type conversion is done, and the types must be the same to be considered equal.

The == operator will compare for equality after doing any necessary type conversions.
 The === operator will not do the conversion, so if two values are not the same 
 type === will simply return false. Both are equally quick.


 ============

== vs ===

const value1 = 5;
const value2 = '5';

console.log(value1 == value2); ////// true
console.log(value1 === value2); //////// false

'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true

=============================

map() vs filter() vs reduce()


const nums = [1, 2, 3, 4, 5];

const numsAddOne = nums.map((value) => value + 1);
console.log(numsAddOne) /////[2, 3, 4, 5, 6]

const evenNums = nums.filter((value) => value % 2 === 0 );
console.log(evenNums) /// [2, 4]
console.log(nums)//// [1, 2, 3, 4, 5]

const sum = nums.reduce((total, current) => {
    return total + current;
}, 0)

console.log(sum); /// 15

======================================================

undefined vs null


Null: It is the intentional absence of the value. It is one of the primitive values of JavaScript.

Undefined: It means the value does not exist in the compiler. It is the global object.


 null == undefined // true
 null === undefined // false

NULL
 null ? console.log("true") : console.log("false") // false

 UNDEFINED
 var temp;
 
if(temp === undefined)
console.log("true");
else
console.log("false");/// true

=================================

What are some JavaScript data types?

JavaScript is a dynamic language with dynamic types.
 Variables in JavaScript are not directly associated with any
  particular value type, and any variable can be assigned (and re-assigned) 
  values of all types:

  // boolean, strings, numbers, BigInt, Symbol
// [], {}, Map, Set - array with uniqe values

================================

Spread  & Rest operator

const users = ['Dylan', 'Per', 'Dollan'];
const allUsers = ['Olivia', ...users];
console.log(allUsers);///// ["Olivia", "Dylan", "Per", "Dollan"]


const user = { firstName: 'Dylan', lastName: 'Israel' };
const fullUser = { channel: 'codingtutorials360', ...user };
console.log(fullUser);//// ›{channel: "codingtutorials360", firstName: "Dylan", lastName: "Israel"}

--------

const user = { firstName: 'Dylan', lastName: 'Israel', channel: 'codingtutorials360' };
const defaults = { channel: 'scrimba', ...user };
console.log(defaults);// {channel: "codingtutorials360", firstName: "Dylan", lastName: "Israel"}
----------
Array and Object Destructuring in JavaScript

The destructuring assignment is a cool feature that came along with ES6. Destructuring is a JavaScript
 expression that makes it possible to unpack values from arrays, or properties from objects, into distinct
  variables. That is, we can extract data from arrays and objects and assign them to variables.

let introduction = ["Hello", "I" , "am", "Sarah"];
let [greeting, pronoun] = introduction;

console.log(greeting);//"Hello"
console.log(pronoun);//"I"
--

function getArray() {
    return ["Hello", "I" , "am", "Sarah"];
} 
let [greeting,pronoun] = getArray();

console.log(greeting);//"Hello"
console.log(pronoun);//"I"