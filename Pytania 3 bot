1. Hoisting ---------


In JavaScript, hoisting is the behavior of moving declarations to the top of a code block. 
This is done at the creation phase of the execution context, before code execution.
console.log(x);
var x = 5;
At runtime, the JavaScript interpreter will implicitly move the declaration of
 the x variable to the top of the code block, as if it were written like this:
var x;
console.log(x);
x = 5;



 This behavior is called hoisting because it appears as if the declaration is being "hoisted" to the top of the code block.

Hoisting only affects declarations, not assignments. In the example above, the assignment x = 5 remains in place.

It's important to note that hoisting only occurs with declarations, not with assignments. For example, consider the following code:

console.log(x);
x = 5;


In this case, the x variable has not been declared, so an error will be thrown when the code is executed.


It's also worth noting that hoisting only applies to variables declared with the var keyword.
 Variables declared with let and const are not hoisted, and attempting to access them before 
 they are declared will result in a ReferenceError.

==============================

2. REST API --------


A REST (Representational State Transfer) API is a type of web service that uses HTTP methods to manipulate data and resources.
 REST APIs are designed to be lightweight, easy to use, and easy to scale.

REST APIs typically use the HTTP methods GET, POST, PUT, PATCH, and DELETE to perform operations on resources.
 Here's a brief description of each method:

GET: Retrieves a resource from the server.
POST: Creates a new resource on the server.
PUT: Replaces an existing resource on the server.
PATCH: Modifies an existing resource on the server.
DELETE: Deletes a resource from the server.
REST APIs use a URI (Uniform Resource Identifier) to identify resources, and HTTP methods to manipulate those resources.
 For example, the following URI identifies a resource representing a list of users:


 REST APIs are a popular way to build APIs for web-based systems because they are lightweight and easy to use. 
 They are also easy to scale, since they do not rely on a specific protocol or implementation.

REST APIs are not the only way to build APIs, but they are a widely used and well-established standard for building APIs on the web.


An API (Application Programming Interface) is a set of rules and protocols that defines how different software systems can
communicate with each other. APIs are often used to allow one application to access the functionality or data of another application.


===========================

3. Methods of building API

There are several ways to build an API (Application Programming Interface), including the following:

REST APIs: REST (Representational State Transfer) APIs are a popular way to build APIs that use HTTP methods to 
manipulate data and resources. REST APIs are easy to use, lightweight, and easy to scale.

GraphQL APIs: GraphQL is a query language for APIs that allows clients to request specific data from the server.
 GraphQL APIs are often more flexible than REST APIs, as they allow clients to specify exactly what data they need
  and receive only that data, rather than a fixed set of data.

gRPC APIs: gRPC (Remote Procedure Calls) is a high-performance, open-source RPC framework that uses HTTP/2 for transport.
 gRPC APIs are designed for low-latency, high-throughput scenarios, and are often used for microservices and other distributed systems.

Webhooks: A webhook is a way for one system to send data to another system in real-time over HTTP. Webhooks are often used
 to build APIs that allow one system to trigger an action in another system, such as sending a message or triggering a build.

Custom APIs: Some APIs are built using a custom protocol or implementation. These APIs may use a proprietary format or
 communication protocol, and may require custom client libraries or SDKs (Software Development Kits) to use.

There are pros and cons to each of these approaches, and the best choice for a particular API will depend on the needs and 
goals of the API and the systems it will be used with.


===============

4. How to menage state in React

Use React's useState hook to add state to functional components. This hook allows you to add state to a functional
 component by returning an array with two elements: the current state value and a function to update it.

import { useState } from 'react';

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

--Use the state property in a class-based component to add state to a class component. The state property is
 an object that stores values that belong to the component and can be updated using the setState method.

 class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}


--Use the context API to share state across components. The context API allows you to create a context provider 
that can be consumed by any component in the component tree. This is useful for sharing state that is required 
by many components and that should be updated in a centralized location.


const MyContext = React.createContext();

class MyProvider extends React.Component {
  state = {
    count: 0
  }

  render() {
    return (
      <MyContext.Provider value={{
        state: this.state,
        incrementCount: () => this.setState({ count: this.state.count + 1 })
      }}>
        {this.props.children}
      </MyContext.Provider>
    );
  }
}

function Child() {
  const { state, incrementCount } = useContext(MyContext);
  return (
    <div>
      <p>You clicked {state.count} times</p>
      <button onClick={incrementCount}>Click me</button>
    </div>
  );
}

function App() {
  return (
    <MyProvider>
      <Child />
    </MyProvider>
  );
}


=====================

5. Class Components, functional components 

In React, there are two types of components: class-based components and functional components.

Class-based components are defined as JavaScript classes and require you to extend the React.Component 
base class. They have a few additional features compared to functional components, such as the ability
 to have a local state, a lifecycle method, and access to this. Here's an example of a class-based component:


        class MyComponent extends React.Component {
        state = {
            count: 0
        }

        render() {
            return (
            <div>
                <p>You clicked {this.state.count} times</p>
                <button onClick={() => this.setState({ count: this.state.count + 1 })}>
                Click me
                </button>
            </div>
            );
        }
        }


Functional components, on the other hand, are just JavaScript functions that accept props as an argument 
and return a React element. They don't have access to a local state or lifecycle methods, but they are
 simpler and easier to write than class-based components. Here's an example of 
a functional component:

        function MyComponent(props) {
        return (
            <div>
            <p>You clicked {props.count} times</p>
            <button onClick={props.incrementCount}>Click me</button>
            </div>
        );
        }


In general, it's recommended to use functional components whenever possible and only use
 class-based components when you need to add state or lifecycle methods to a component.

============

6. Lifecycle of component


unctional components do not have a lifecycle in the same way that class-based components do. 
In a class-based component, you can define methods that are called at different stages of the component's lifecycle,
 such as when it is mounted to the DOM or when it receives new props. 
These methods include componentDidMount, shouldComponentUpdate, componentDidUpdate, and componentWillUnmount.

Functional components, on the other hand, do not have these lifecycle methods. They are just 
simple functions that accept props as an argument and return a React element.

However, functional components can be enhanced with additional functionality using React hooks.
 One such hook is the useEffect hook, which allows you to perform side effects in a functional component. 
 This can be used to simulate lifecycle methods, such as componentDidMount or 
componentWillUnmount.

Here's an example of using the useEffect hook to simulate the componentDidMount lifecycle method:


        import { useEffect } from 'react';

        function MyComponent(props) {
        useEffect(() => {
            // componentDidMount logic goes here
        }, []);

        return (
            // component JSX goes here
        );
        }


It's important to note that the useEffect hook is called after every render, not just once like componentDidMount.
 However, you can control when the effect is executed by passing a second argument to useEffect, which is an array of 
 values that the effect depends on. If you pass an empty array, the effect will only be executed once, when the component is first mounted.


====================


7. Pass by value and pass by reference

In programming, "pass by value" and "pass by reference" refer to the way in which a 
function's arguments are passed when the function is called.

In a "pass by value" language, when you pass an argument to a function, the function
 creates a new memory location for the argument and stores the value of the argument 
 in that location. This means that any changes made to the argument within the function have no effect on the
 original value of the argument outside of the function.

For example, in JavaScript, primitive data types (such as numbers and strings) are passed by value. Consider the following code:

        function increment(x) {
        x++;
        }

        let a = 1;
        increment(a);
        console.log(a); // Output: 1

In this example, the value of a is passed to the increment function, and a new memory location is 
created for the argument x. The value of x is then incremented, but this change has no effect on the original value of a.

In a "pass by reference" language, when you pass an argument to a function, 
the function does not create a new memory location for the argument. Instead, the function is given
 a reference to the memory location where the argument is stored. This means that any changes 
made to the argument within the function are reflected in the original value of the argument outside of the function.

For example, in JavaScript, objects (including arrays) are passed by reference. Consider the following code:

        function addToArray(arr) {
        arr.push(1);
        }

        let a = [];
        addToArray(a);
        console.log(a); // Output: [1]

In this example, the value of a is passed to the addToArray function, and the function is given a reference
 to the memory location where the array is stored. The function then pushes a new element to the array, which modifies the original array.

It's important to understand the difference between pass by value and pass by reference, as it can affect the way you write your code and the way your program behaves.

===============

8. FIrebase

Firebase can be used in a variety of ways by front-end developers. Some common uses of Firebase for front-end development include:

Real-time database: Firebase provides a real-time database that can be used to store and sync data across multiple devices in real-time. This can be useful for building applications that need to display live data or that require frequent updates.

User authentication: Firebase provides built-in support for user authentication, including support for popular identity providers like Google, Facebook, and more. This can be useful for building applications that require user login or that need to manage user permissions.

Hosting: Firebase provides hosting for static websites and web applications, which can be useful for quickly deploying front-end projects.

Cloud storage: Firebase provides cloud storage for storing and serving user-generated content, such as images or videos.

Analytics: Firebase provides analytics tools that can be used to track user behavior and measure the effectiveness of an application.

Overall, Firebase is a powerful platform that can be used by front-end developers to build and manage a variety of applications.


============

9. == and === operator

In JavaScript, the double equals operator (==) is used to compare the values of two operands,
 while the triple equals operator (===) is used to compare the values and types of two operands.

Here are some examples to illustrate the difference between == and ===:

    console.log(1 == "1"); // true, because the value of "1" is converted to a number before the comparison
    console.log(1 === "1"); // false, because the type of 1 (number) is not equal to the type of "1" (string)
    console.log(null == undefined); // true, because both null and undefined are considered equal values
    console.log(null === undefined); // false, because null and undefined are different types


As a general rule, it is recommended to use the triple equals operator (===) whenever possible,
 as it provides more strict type checking and can help prevent unintended type coercion. However, 
 there are some cases where the double equals operator (==) may be useful, such as when comparing values that might be null or undefined.